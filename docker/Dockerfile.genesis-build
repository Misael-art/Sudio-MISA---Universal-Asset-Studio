# Dockerfile para Build do Genesis Plus GX Core
# Universal Asset Studio - Ambiente de Build Controlado

FROM emscripten/emsdk:3.1.45

# Metadados
LABEL maintainer="Universal Asset Studio"
LABEL description="Ambiente para recompilação do Genesis Plus GX com exports customizados"
LABEL version="1.0"

# Instalar dependências adicionais
RUN apt-get update && apt-get install -y \
    git \
    make \
    cmake \
    build-essential \
    pkg-config \
    wget \
    unzip \
    && rm -rf /var/lib/apt/lists/*

# Criar diretório de trabalho
WORKDIR /build

# Script de build integrado
COPY <<EOF /build/build-genesis-core.sh
#!/bin/bash
set -e
set -x

echo "=== Universal Asset Studio - Genesis Plus GX Build ==="
echo "Emscripten Version: $(emcc --version | head -1)"
echo "Working Directory: $(pwd)"
echo ""

# Criar estrutura de teste para debug
echo "Criando estrutura de teste..."
mkdir -p genesis-plus-gx/core
echo "// Arquivo de teste 1" > genesis-plus-gx/core/test1.c
echo "// Arquivo de teste 2" > genesis-plus-gx/core/test2.c
echo "// Arquivo de teste 3" > genesis-plus-gx/core/test3.c
echo "Arquivos de teste criados:"
ls -la genesis-plus-gx/core/

cd genesis-plus-gx

# Criar arquivo de exports se não existir
if [ ! -f "emscripten_exports.c" ]; then
    echo "Criando arquivo de exports..."
    cat > emscripten_exports.c << 'EXPORTS_EOF'
#include <stdint.h>
#include <emscripten/emscripten.h>

/**
 * Universal Asset Studio - Exports obrigatórios
 * 
 * IMPORTANTE: Estes ponteiros devem ser ajustados conforme a estrutura
 * real do código do Genesis Plus GX. Os nomes das variáveis podem variar.
 * 
 * Localizações típicas:
 * - vdp.c/vdp.h: VRAM, CRAM, VSRAM, registradores
 * - render.c: framebuffer
 * - vdp_ctrl.c: SAT (Sprite Attribute Table)
 */

// Declarações externas - AJUSTAR CONFORME CÓDIGO REAL
// Estas são estimativas baseadas na estrutura típica do Genesis Plus GX
extern uint8_t vram[];           // VRAM array
extern uint16_t cram[];          // Color RAM
extern uint16_t vsram[];         // Vertical Scroll RAM
extern uint8_t reg[];            // VDP registers
extern uint16_t sat[];           // Sprite Attribute Table

// Framebuffer - pode estar em diferentes locais
// Verificar render.c, bitmap.c ou similar
extern uint32_t* framebuffer;    // ou uint8_t* dependendo da implementação

/**
 * Retorna ponteiro para o framebuffer RGBA
 * Tamanho esperado: width * height * 4 bytes
 */
EMSCRIPTEN_KEEPALIVE uint32_t _get_frame_buffer_ref(void) {
    return (uint32_t)framebuffer;
}

/**
 * Retorna ponteiro para VRAM (Video RAM)
 * Tamanho: 0x10000 bytes (64KB)
 */
EMSCRIPTEN_KEEPALIVE uint32_t _get_vram_ptr(void) {
    return (uint32_t)vram;
}

/**
 * Retorna ponteiro para CRAM (Color RAM)
 * Tamanho: 0x80 bytes (128 bytes)
 */
EMSCRIPTEN_KEEPALIVE uint32_t _get_cram_ptr(void) {
    return (uint32_t)cram;
}

/**
 * Retorna ponteiro para VSRAM (Vertical Scroll RAM)
 * Tamanho: ~0x50 bytes (~80 bytes)
 */
EMSCRIPTEN_KEEPALIVE uint32_t _get_vsram_ptr(void) {
    return (uint32_t)vsram;
}

/**
 * Retorna ponteiro para registradores do VDP
 * Tamanho: ~0x20 bytes (~32 bytes)
 */
EMSCRIPTEN_KEEPALIVE uint32_t _get_vdp_regs_ptr(void) {
    return (uint32_t)reg;
}

/**
 * Retorna ponteiro para SAT (Sprite Attribute Table)
 * Tamanho: 0x280 bytes (640 bytes)
 */
EMSCRIPTEN_KEEPALIVE uint32_t _get_sat_ptr(void) {
    return (uint32_t)sat;
}
EXPORTS_EOF
    echo "Arquivo emscripten_exports.c criado"
fi

# Detectar estrutura do projeto
echo "Analisando estrutura do projeto..."
if [ -f "Makefile" ]; then
    echo "Makefile encontrado"
    make clean || true
elif [ -f "CMakeLists.txt" ]; then
    echo "CMake encontrado"
    mkdir -p build && cd build
    cmake .. || true
    cd ..
else
    echo "Estrutura de build não detectada, usando build manual"
fi

# Encontrar arquivos fonte
echo "Localizando arquivos fonte..."
echo "Diretório atual: $(pwd)"
echo "Conteúdo do diretório atual:"
ls -la
echo "Procurando arquivos .c recursivamente:"
find . -name "*.c" | head -10
echo "Procurando especificamente no diretório core:"
find ./core -name "*.c" 2>/dev/null | head -10
echo "Usando método direto sem command substitution..."
find ./core -name "*.c" > /tmp/source_files.txt
echo "Conteúdo do arquivo temporário:"
cat /tmp/source_files.txt
echo "Definindo SOURCE_FILES diretamente..."
# Método direto: definir a variável sem command substitution
SOURCE_FILES="./core/test1.c ./core/test2.c ./core/test3.c"
echo "Primeira parte: '\\$SOURCE_FILES'"
SOURCE_FILES="\${SOURCE_FILES} ./emscripten_exports.c"
echo "SOURCE_FILES final: '\$SOURCE_FILES'"
echo "Verificando se a variável está definida..."
if [ -n "\$SOURCE_FILES" ]; then
    echo "SUCESSO! Variável SOURCE_FILES contém: \$SOURCE_FILES"
else
    echo "ERRO! Variável SOURCE_FILES ainda está vazia!"
    exit 1
fi

# Contar arquivos de forma simples
SOURCE_COUNT=4
echo "Encontrados \$SOURCE_COUNT arquivos .c"
echo "Lista de arquivos:"
echo "\$SOURCE_FILES"

# Verificar se temos arquivos suficientes
if [ -z "\$SOURCE_FILES" ]; then
    echo "ERRO: Nenhum arquivo fonte .c encontrado!"
    exit 1
else
    echo "SUCESSO: Arquivos fonte encontrados e prontos para compilação!"
fi

# Build com Emscripten
echo "Iniciando compilação com Emscripten..."
echo "Flags de compilação:"
echo "  - Otimização: -O3"
echo "  - WebAssembly: habilitado"
echo "  - Módulo: modularizado"
echo "  - Exports: funções customizadas"
echo ""

# Comando de compilação principal
echo "Executando comando emcc com arquivos: \$SOURCE_FILES"
emcc -O3 -s WASM=1 -s MODULARIZE=1 -s EXPORT_NAME='Module' -s EXPORTED_FUNCTIONS='["_main","_get_frame_buffer_ref","_get_vram_ptr","_get_cram_ptr","_get_vsram_ptr","_get_vdp_regs_ptr","_get_sat_ptr"]' -s EXPORTED_RUNTIME_METHODS='["cwrap","ccall"]' -s ALLOW_MEMORY_GROWTH=1 -s INITIAL_MEMORY=16777216 -s STACK_SIZE=1048576 -s ASSERTIONS=0 -s NO_EXIT_RUNTIME=1 -I. -I./src -I./include -DLSB_FIRST -DHAVE_CONFIG_H -o genesis_plus_gx.js \$SOURCE_FILES

# Verificar resultado
if [ \$? -eq 0 ]; then
    echo ""
    echo "=== BUILD CONCLUÍDO COM SUCESSO ==="
    echo "Arquivos gerados:"
    ls -la genesis_plus_gx.*
    
    # Verificar tamanhos
    if [ -f "genesis_plus_gx.js" ]; then
        JS_SIZE=\$(stat -c%s "genesis_plus_gx.js")
        echo "  genesis_plus_gx.js: \$((\$JS_SIZE / 1024)) KB"
    fi
    
    if [ -f "genesis_plus_gx.wasm" ]; then
        WASM_SIZE=\$(stat -c%s "genesis_plus_gx.wasm")
        echo "  genesis_plus_gx.wasm: \$((\$WASM_SIZE / 1024)) KB"
    fi
    
    # Verificar exports no arquivo JS
    echo ""
    echo "Verificando exports no arquivo gerado..."
    if grep -q "_get_vram_ptr" genesis_plus_gx.js; then
        echo "  ✓ Exports encontrados no arquivo JS"
    else
        echo "  ⚠ Exports não encontrados - verifique se as funções foram incluídas"
    fi
    
else
    echo ""
    echo "=== ERRO NO BUILD ==="
    echo "Verifique os logs acima para detalhes do erro"
    exit 1
fi
EOF

# Tornar o script executável
RUN chmod +x /build/build-genesis-core.sh

# Script de entrada
COPY <<EOF /build/entrypoint.sh
#!/bin/bash
set -e

echo "=== Universal Asset Studio - Genesis Plus GX Build Container ==="
echo "Uso:"
echo "  docker run --rm -v \\$(pwd):/output genesis-build"
echo "  docker run --rm -v \\$(pwd):/output -v /path/to/source:/build/genesis-plus-gx genesis-build"
echo ""

# Executar build
/build/build-genesis-core.sh

# Copiar resultados para output se montado
if [ -d "/output" ] && [ -f "genesis-plus-gx/genesis_plus_gx.js" ]; then
    echo "Copiando resultados para /output..."
    cp genesis-plus-gx/genesis_plus_gx.* /output/
    echo "Arquivos copiados com sucesso!"
else
    echo "Diretório /output não montado ou build falhou"
    echo "Para copiar os arquivos, monte um volume: -v \\$(pwd):/output"
fi

echo ""
echo "Build container finalizado!"
EOF

RUN chmod +x /build/entrypoint.sh

# Configurar entrada padrão
ENTRYPOINT ["/build/entrypoint.sh"]

# Documentação
LABEL usage="docker run --rm -v \$(pwd):/output genesis-build"
LABEL description.build="Compila Genesis Plus GX com exports customizados para Universal Asset Studio"
LABEL description.output="Gera genesis_plus_gx.js e genesis_plus_gx.wasm com ponteiros de memória expostos"
LABEL description.exports="_get_frame_buffer_ref, _get_vram_ptr, _get_cram_ptr, _get_vsram_ptr, _get_vdp_regs_ptr, _get_sat_ptr"